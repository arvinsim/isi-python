<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>reveal.js - The HTML Presentation Framework</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="../revealjs/css/reveal.css">
		<link rel="stylesheet" href="../revealjs/css/theme/black.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="../revealjs/lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? '../revealjs/css/print/pdf.css' : '../revealjs/css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="../revealjs/lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">
			<div class="slides">
                <section>
                    <h1>Modules and Packages</h1>
                </section>

				<section>
					<h2>Modules</h2>
				</section>

				<section>
					<h3>modules</h3>

					<section>
						<p>A module is a file containing Python definitions and statements</p>
					</section>

					<section>
						<p>The file name is the module name with the suffix, <code>.py</code> appended.</p>
						<table>
							<tr>
								<th>module name</th>
								<th>filename</th>
							</tr>
							<tr>
								<td>fubar</td>
								<td>fubar.py</td>
							</tr>
						</table>
					</section>

                    <section>
                        <p><strong>DON'T</strong> use the dot(.) character in naming modules. You will see later why this is the case.</p>
                    </section>

				</section>

				<section>
					<h3>import Statement</h3>

					<section>
						<p>To use a module, we use the <code>import</code> command</p>
						<pre><code>
    # import a file
    import fubar
						</code></pre>
					</section>

					<section>
						<p><code>import X</code> imports the module X, and creates a reference to that module in the
						current namespace.</p>
					</section>

                    <section>
                        <p>In other words, after you've run this statement, you can use <code>X.name</code> to
                            refer to things defined in module X.</p>
                    </section>

					<section>
						<p>Assume that we have this simple module</p>
						<pre><code>
    # physics.py

    solar_luminous_efficacy = 93

    def get_speed_of_light():
    	return 299792458

    class ElectroMagneticConstants(object):
    	magnetic_flux_quantum = 2.067833758e-15

    class ElectronAtomConstants(object):
        def __init__(self):
            self.electron_rest_mass = 9.10938291e-31
						</code></pre>
					</section>

					<section>
						<p>If we import <code>physics.py</code>, we can access definitions and statements.</p>
						<p>That includes variables, functions, classes, etc.</p>
						<pre><code>
    # import physics.py file
    import physics

    # use it
    print physics.solar_luminous_efficacy  # variable
    print physics.get_speed_of_light()  # function
    # class attribute
    print physics.ElectroMagneticConstants.magnetic_flux_quantum

    eac = physics.ElectronAtomConstants()  # Instantiate a class
    print eac.electron_rest_mass  # instance variable
						</code></pre>
					</section>
				</section>

				<section>
					<h3>from X import statement</h3>

                    <section>
                        <p><code>from X import a, b, c</code> imports the module X, and creates references in the current namespace
                        to the given objects.</p>
                    </section>

                    <section>
                        <p>In other words, you can now use <code>a</code> and <code>b</code> and <code>c</code> in your program</p>
                    </section>

                    <section>
                        <pre><code></code></pre>
                    </section>
				</section>

				<section>
					<h3>from X import * statement</h3>

					<section>
						<p><code>from X import *</code> imports the module X, and creates references in the current namespace to
						all public objects defined by that module(that is, everything that doesn't have a name
						starting with "__").</p>
					</section>

					<section>
						<p>In other words, after you've run this statement, you can simply use a plain
							<code>name</code> to refer to things defined in module X. But X itself is not defined,
							so <code>X.name</code> doesn't work</p>
					</section>

					<section>
						<pre><code></code></pre>
					</section>

					<section>
						<p>If <code>name</code> was already defined, it is replaced by the new version</p>
					</section>

					<section>
						<pre><code></code></pre>
					</section>

					<section>
						<p>If <code>name</code> in X is changed to point to some other object, your module won't notice</p>
					</section>

					<section>
						<pre><code>

						</code></pre>
					</section>

				</section>

                <section>
                    <h3>dir and help function</h3>

                    <section>
                        <p>Two very important functions come in handy when exploring modules in Python - the <code>dir</code> and <code>help</code> functions</p>
                    </section>

                    <section>
                        <p>Assume that we have this module</p>
                        <pre><code>
    # sample.py
    sample_variable = "a"
    def sample_function():
        """
        A sample function
        """
        pass
    class SampleClass(object):
        """
        A sample class
        """
        pass
                        </code></pre>
                    </section>

                    <section>
                        <p>Using <code>dir</code> on a module shows a list that contains the names of the module's attributes</p>
                        <pre><code>
    import sample
    print dir(sample)
    """
    ['SampleClass', '__author__', '__builtins__', '__doc__',
    '__file__', '__name__', '__package__', 'sample_function',
    'sample_variable']
    """
                        </code></pre>
                    </section>

                    <section>
                        <p>Using <code>help</code> on a module generates a help page on that module</p>
                        <pre><code>
    import sample
    print help(sample)

    """
    help on module sample:

    name
        sample - # sample.py

    file
        /../../../../sample.py

    classes
        __builtin__.object
        sampleclass

        class sampleclass(__builtin__.object)
        |  a sample class
        |
        |  data descriptors defined here:
        |
        |  __dict__
        |      dictionary for instance variables (if defined)
        |
        |  __weakref__
        |      list of weak references to the object (if defined)

    functions
        sample_function()
            a sample function

    data
        sample_variable = 'a'

    none
    """
                        </code></pre>
                    </section>
                </section>

                <section>
                    <h2>Packages</h2>
                </section>

				<section>
					<h3>Creating Packages</h3>

					<section>
						<p>Packages are namespaces which contain multiple packages and modules themselves. They are simply directories, but with a twist.</p>
					</section>

					<section>
						<p>Each package in Python is a directory which <strong>MUST</strong> contain a special file called <code>__init__.py</code></p>
						<pre><code>
	physics_package/
		__init__.py
		classical.py
		thermodynamics.py
		electromagnetism.py
		relativity.py
		quantum.py
                        </code></pre>
					</section>

                    <section>
                        <p>This file can be empty, and it indicates that the directory it contains is a Python package, so it can be imported the same way a module can be imported.</p>
                    </section>

                    <section>
                        <p>It executes when the module is loaded. It is analogous to the constructor for classes.</p>
                    </section>

				</section>

                <section>
                    <h3>Importing a Package</h3>

                    <section>
                        <p>To import a package, use the same syntax as you would import a module</p>
                        <pre><code>
    import physics_package
    print help(physics_package)
    """
    Help on package physics_package:

    NAME
        physics_package

    FILE
        /../../../physics_package/__init__.py

    PACKAGE CONTENTS
        classical
        electromagnetism
        quantum
        relativity
        thermodynamics

    AUTHOR
        avsimon

    None
    """
                        </code></pre>
                    </section>

                    <section>
                        <p>Note that you can also use the <code>from X import</code> and <code>from X import *</code>
                        form of importing</p>
                        <pre><code>
    from physics_package import classical, electromagnetism
    print help(classical)
    print help(electromagnetism)
                        </code></pre>
                    </section>
                </section>

                <section>
                    <h3>Nesting Packages</h3>

                    <section>
                        <p>Packages can be nested</p>
						<pre><code>
    parent_package/
        __init__.py
            child1_package/
                __init_.py
            child2_package/
                __init__.py
                grandchild_package/
                    __init__.py
                        </code></pre>
                    </section>
                </section>

                <section>
                    <h3>Importing Nested Packages or Modules</h3>

                    <section>
                        <p>To import nested packages or modules, you can access the child modules packages by using the
                        dot operator. The dot operator acts like a directory.</p>
                        <pre><code>
    import parent_package.child2_package.grandchild_package
    print help(parent_package.child2_package.grandchild_package)
                        </code></pre>
                    </section>

                    <section>
                        <p>The previous example was too long. To make it simpler, we can use the <code>as</code> keyword
                        to alias modules or packages</p>
                        <pre><code>
    import parent_package.child2_package.grandchild_package as grandchild
    print help(grandchild)
                        </code></pre>
                    </section>

                    <section>
                        <p>It could also be done using the <code>from * import</code> format</p>
                        <pre><code>
    from parent_package.child2_package import grandchild_package
    print help(grandchild_package)
                        </code></pre>
                    </section>
                </section>

                <section>
                    <h2>Standard Modules</h2>
                    + sys
                    + string
                    + datetime
                    + math
                    + random
                    + file
                    https://docs.python.org/2/library/
                </section>
            </div>
		</div>

		<script src="../revealjs/lib/js/head.min.js"></script>
		<script src="../revealjs/js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: '../revealjs/plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: '../revealjs/plugin/zoom-js/zoom.js', async: true },
					{ src: '../revealjs/plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
