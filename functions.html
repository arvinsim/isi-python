<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>reveal.js - The HTML Presentation Framework</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>
		<div class="reveal">
			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>Functions</h1>
				</section>

                <section>
                    <h2>What are Functions?</h2>

                    <section>
                        <p>A function is a named sequence of statements that performs a computation</p>
                    </section>

                    <section>
                        <p>We have been using functions already in our previous lessons.</p>
                        <pre><code>
    len() cmp() list() min() max()
                        </code></pre>
                    </section>

                    <section>
                        <p>These are called <em>built-in</em> functions. They are already built-into the language itself.</p>
                    </section>
                </section>

                <section>
                    <h2>Writing your own functions</h2>

                    <section></section>

                    <section>
                        <p>Although built-in functions are useful, it certainly does not cover all our use cases. That's
                            why programming languages allow us to define our own.</p>
                    </section>

                    <section>
                        <h3>Defining a function</h3>

                        <p>Psuedocode</p>
                        <pre><code>
    def function_name(parameters):
        code block
        ...
        optional return
                        </code></pre>
                    </section>

                    <section>
                        <p>Basic Examples</p>

                        <pre><code>
    def foo():
        u = "thought"
        print u

    def who(goat):
        print goat

    def bar(b, c):
        b = "latitude"
        c = 2
        print b
        print c
                        </code></pre>
                    </section>

                    <section>
                        <p>Defining a function is all well and good, but it does nothing on its own. To actually
                            execute the statements inside a function, you need to "call" it.
                        </p>
                    </section>

                    <section>
                        <h3>Calling a Function</h3>

                        <pre><code>
    function_name()
    function_name([arguments])
                        </code></pre>
                    </section>

                    <section>
                        <h3>Basic Examples</h3>
                        <pre><code>
    foo()
    who("you?")
    bar("walay", "pulos")
                        </code></pre>
                    </section>
                </section>

                <section>
                    <h2>Basic Arguments Passing</h2>

                    <section></section>

                    <section>
                        <p>The function examples that we used so far just executes a bunch of statements. It's no different from
                        just running them normally.</p>
                        <p>It would be more useful if we could somehow influence the statements inside it.</p>
                    </section>

                    <section>
                        <p>To do that, we need to learn how to pass arguments</p>
                    </section>

                    <section>
                        <h3>Basic Example</h3>
                        <pre><code>
    def double(number):
        print number * 2

    double(5) # 5 is the argument. This function call outputs 10
                        </code></pre>
                    </section>


                    <section>
                        <p>There can be more than one parameter</p>

                        <pre><code>
    def show_full_name(first_name, last_name):
        print "My full name is {} {}".format(first_name, last_name)

    show_full_name("Arthur", "Simon")
                        </code></pre>
                    </section>

                    <section>
                        <p>Any variable type can be passed to functions...</p>
                        <pre><code>
    def yay(lots, of, parameters, here):
        print lots
        print of
        print parameters
        print here

    yay(1 + 2, "what", [100,200], { "ha": "ho" })
                        </code></pre>
                    </section>

                    <section>
                        <p>...even functions themselves</p>

                        <pre><code>
    def foo(f):
        print f

    def bar():
        pass

    foo(bar) # Outputs &lt;function bar at 0x1062eb0c8&gt;
                        </code></pre>
                    </section>

                    <section>
                        <p>Example of how to use passed functions</p>
                        <pre><code>
    def minion(x):
        print "minion has the {}".format(x)

    def boss(f,x):
        f(x)

    boss(minion, "banana!")
                        </code></pre>
                    </section>

                    <section>
                        <p>What we saw are just the basics. Later we will tackle more advanced forms of parameters</p>
                    </section>
                </section>


                <section>
                    <h2>Flow of Execution</h2>

                    <section></section>
                </section>

				<section>
                    <h2>Functions with return values</h2>

                    <section></section>

                    <section>
                        <p>So far, most of our functions just do some operations and print out some stuff</p>
                        <pre><code>
    def show_greeting():
        print "Hello World!"

    show_greeting() # Prints the greeting
                        </code></pre>
                    </section>

                    <section>
                        <h3>More examples</h3>

                        <pre><code>
                        </code></pre>
                    </section>


                    <section>
                        <p>There is a keyword that allows us to "return" a value from a function to its caller</p>
                        <pre><code>
    def show_greeting():
        return "Hello World!"

    print show_greeting()  # Prints out the returned string
                        </code></pre>
                    </section>

                     <section>
                        <p>You can also ignore the return value or assign it to a variable</p>
                        <pre><code>
    def show_greeting():
        return "Hello World!"

    show_greeting()  # Does nothing

    # Assign the returned value to a variable and print
    # them out
    greeting = show_greeting()
    print greeting
                        </code></pre>
                    </section>

					<section>
                        <p>You can pass the return value of a function to another function</p>
                        <pre><code>
    def double(x):
        return x * 2

    def triple(y):
        return y * 3

    def quadruple(z):
        return z * 4

    print quadruple(triple(double(2))) # Outputs 48
                        </code></pre>
					</section>
				</section>

				<section>
                    <h2>Variable Scoping</h2>

                    <section></section>

                    <section>
                        <p>A function has its own scope.</p>
                        <p>That is, whatever variables or functions that you declared in it...is accessible only to
                            itself</p>
                    </section>

                    <section>
                        <img src="http://www.ifac.cnr.it/~zoppetti/corsopython/files/img/LEGB.png" alt="scopes"/>
                    </section>

                    <section>
                        <p>You can use a variable outside of the function inside a function</p>
                        <pre><code>
    message = 'outside'

    def foobar():
        print message

    foobar() # Outputs 'outside'
                        </code></pre>
                    </section>

                    <section>
                        <p>Variables outside a function would not be affected by operations or declarations inside a
                           function</p>
                        <pre><code>
    message = "Outside the function"
    count = 5

    def foobar():
        message = "Inside the function"
        count = 10
        count += 1
        print message
        print count

    foobar() # Outputs "Inside the function" and 11
    print message  # Outputs "Outside the function"
    print count # Outputs 5
                        </code></pre>
                    </section>

                    <section>
                        <p>Even if functions have the same variable names, they won't conflict with each other</p>
                        <pre><code>
    def akong_silingan():
        phone = "iPhone"
        print phone

    def ako():
        phone = "Samsung"
        print phone

    akong_silingan() # Outputs "iPhone"
    ako() # Outputs "Samsung"
                        </code></pre>
                    </section>

                    <section>
                        <p>It's possible to nest functions</p>
                        <pre><code>
    message = "global"

    def foo():
        message = "in foo"

        def bar():
            message = "in bar"
            print message

        bar()
        print message

    # 'in bar'
    # 'in foo'
    foo()
                        </code></pre>
                    </section>
				</section>

                <section>
                    <h2>Named Parameters</h2>
                    <section></section>

                    <section>
                        <p>So far, what we have been doing is passing arguments via their position relative to the order
                            in the parameter definitions. But there is another way to pass arguments. We can pass arguments
                            via <em>named parameters</em>
                        </p>
                    </section>

                    <section>
                        <p>You can use the parameter name to specify it's respective argument</p>
                        <pre><code>
    def get_full_name(first_name, middle_name, last_name):
        return first_name + " " + middle_name + " " + last_name

    print get_full_name(first_name="Arthur",
                        middle_name="T.",
                        last_name="Simon")
                        </code></pre>
                    </section>

                    <section>
                        <p>This allows us to pass arguments regardless of position</p>
                        <pre><code>
    def get_full_name(first_name, middle_name, last_name):
        return first_name + " " + middle_name + " " + last_name

    # The preceding function call and the 2 function call below
    # will output the same string
    print get_full_name(middle_name="T.",
                        last_name="Simon",
                        first_name="Arthur")
    print get_full_name(last_name="Simon",
                        middle_name="T.",
                        first_name="Arthur")
                        </code></pre>
                    </section>
                </section>

				<section>
                    <h2>Default/Optional Parameters </h2>

                    <section></section>

                    <section>
                        <p>Supposed that you have a function where we seem to repeatedly pass the same value over and over again</p>
                        <pre><code>
    def appendPunctuation(sentence, mark):
        return sentence + mark

    print appendPunctuation("I'm first", '.')
    print appendPuncatiation("I'm second", '.')
    print appendPunctuation("I'm third", '.')
                        </code></pre>
                    </section>

                    <section>
                        <p>Function parameters can be defined to have a default value so you don't have to pass parameters, especially
                        ones that seem to be used most of the time</p>
                        <pre><code>
    def appendPunctuation(sentence, mark='.'):
        return sentence + mark

    print appendPunctuation("I'm first")
    print appendPuncatiation("I'm second")
    print appendPunctuation("I'm third")
                        </code></pre>
                    </section>

                    <section>
                       <p>You can have as many optional parameters as you want...</p>
                       <pre><code>
    def one_option(a=1):
        pass

    def more_options(a, b=1, c=1):
        pass

    def whole_lotta_options(a=1, b=1, c=1, d=1, e=1):
        pass

    one_option()
    more_options(1)
    whole_lotta_options()
                       </code></pre>
                    </section>

                    <section>
                        <p>...but it needs to be after the required parameters</p>
                        <pre><code>
    # This will raise a syntax error
    def so_wrong(a=0, b, c):
        pass
                        </code></pre>
                    </section>

                    <section>
                        + mutable types as defaults gotcha
                    </section>

                    <section>
                        <p>So far, we have been passing the functions the usual way(positional). But there is another
                        way to pass parameters that is potentially more readable</p>
                    </section>

                    <section>
                        <p>We can pass parameters using keywords</p>
                        <pre><code>
                        </code></pre>
                    </section>
				</section>

                <section>
                    <h2>Arbitrary number of arguments</h2>
                    + *args
                    + **kwargs
					+ combine *args, **kwargs
				</section>

                <section>
                    <h3></h3>Why functions?
                    <section>
                        + Creating a new function gives you an opportunity to name a group of statements, which makes your program easier to read and debug.
                        + Functions can make a program smaller by eliminating repetitive code. Later, if you make a change, you only have to make it in one place.
                        + Dividing a long program into functions allows you to debug the parts one at a time and then assemble them into a working whole.
                        + Well-designed functions are often useful for many programs. Once you write and debug one, you can reuse it.
                    </section>
                </section>

				<section>
					+ exercises
					+ Simple
						+ Lyrics

					+ Hard
						+
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
